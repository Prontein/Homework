Данный вариант приложения рассчитан только для копирования файлов от клиента серверу и наоборот. Для запуска программы запускаем сначала файл Main в NSServer, затем MainApplication в NSClient.

![image](https://user-images.githubusercontent.com/77588897/124600428-21d94780-de80-11eb-95ae-53afc1c91cdc.png)

После запуска приложения, для получения доступа к своему рабочему каталогу на сервере, необходимо зарегистрироваться, либо подкючиться с уже созданным аккаунтом.

![image](https://user-images.githubusercontent.com/77588897/124601773-a9738600-de81-11eb-93b3-ae7369c6a17e.png)

При регистрации на сервере создается каталог с именем, присвоенным от логина пользователя. Данный каталог будет отображаться как домашний при последующих подключения пользователя. 
С сервера не приходит информация о полном пути этого каталога, так как пользователь не должен знать о серверной структуре и поэтому выше своего каталога сделать просмотр невозможно.

Для копирования файла необходимо выбрать нужный файл в окне отображения каталога, после выбора и нажатия на кнопку копирование, необходимо дождаться пока файл отобразится в нужной нам директории. 
![image](https://user-images.githubusercontent.com/77588897/124603419-5ac6eb80-de83-11eb-8405-b79dc4ec4064.png)

В случае если файл с таким именем уже будет существовать в нужной нам директории, программа отобразит предупреждение и остановит процесс копирования.
![image](https://user-images.githubusercontent.com/77588897/124604214-27d12780-de84-11eb-8ed8-73e515302d3f.png)

Касательно кода.

Общение между клиентом и сервером происходим путем отправки JSON сообщений, именуемых в проекте MessageDTO. В сообщении находятся необходимые указатели типа команд, а также данные для получения списка каталога на сервере и информации о его содержимом.
Для клиента выполняемые им действия обрабатываются в классе MainController(нажатие кнопок, выбор файла или директории), а обработка каталогов и информации о файлах производится в классе PanelController. После сбора данных из PanelControllera, Main передает их в класс NettyClient, который заварачивает их в JSON сообщение и передает по каналу.

Изначально для работы клиента установлены только 3 обработчика - стандартныe String Encoder и Decoder, а так же пользовательский CommandHandler. В случае передачи файлов на сервер , в pipline на первое место устанавливается стандартный ChunkedWriteHandler, который после окончания записи файла себя удаляет. Если же происходим прием файла от сервера то так же добавляется пользовательский BigFilesWriteHandler,который по окончанию записи файла удалит себя и ChunkedWriteHandler.

![image](https://user-images.githubusercontent.com/77588897/124608601-49cca900-de88-11eb-9cef-70cda0fe65d5.png)

Задача CommandHandler состоит в том, чтобы принять сообщение от сервера и конвертировать его в Gson. Через ссылку (Callback) передаем полученное сообщение в MainController, который с помощью commandDictionary обрабатывает их в зависимости от типа комманды. Так как в сообщении уже находятся готовые поля, то в словаре команд находятся классы которые из полученного сообщения вызывают необходимые методы с этими данными в контроллере.

Для сервера порядок работы с обработчиками в pipeline аналогичен клиенту. CommandHandler отвечает за прием сообщений от клиента и его конвертирование, для дальнейшей обработки через dictionaryService. ServerHandler работает с каталогами на стороне сервера, аналогично PanelControllery на клиенте. DatabaseHandler обрабатывает серверные запросы к базе данных.

